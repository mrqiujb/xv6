## Lab: xv6 lazy page allocation

### Eliminate allocation from sbrk() ([easy](https://pdos.csail.mit.edu/6.828/2020/labs/guidance.html))

​	Your first task is to delete page allocation from the sbrk(n) system call implementation, which is the function sys_sbrk() in sysproc.c. The sbrk(n) system call grows the process's memory size by n bytes, and then returns the start of the newly allocated region (i.e., the old size). Your new sbrk(n) should just increment the process's size (myproc()->sz) by n and return the old size. It should not allocate memory -- so you should delete the call to growproc() (but you still need to increase the process's size!).

​	您的第一个任务是删除sbrk(n)系统中页面分配的部分。Sbrk(n)系统调用将进程的内存大小增加n字节，然后返回新分配区域（即旧大小）的开始。您的新sbrk（n）应该只是将进程的大小（myproc（）->sz）增加n，然后返回旧的大小。它不应该分配内存--所以你应该删除对growproc()的调用（但你仍然需要增加进程的大小！）。

​	Try to guess what the result of this modification will be: what will break?	

​	试着猜猜这个修改的结果会是什么:什么地方会发生错误？

​	当使用页面时便发生了错误，系统正常使用这个页面采用walk等函数，然后没有发现与虚拟页面对应的物理页面

​	Make this modification, boot xv6, and type `echo hi` to the shell. You should see something like this:

```c
init: starting sh
$ echo hi
usertrap(): unexpected scause 0x000000000000000f pid=3
            sepc=0x0000000000001258 stval=0x0000000000004008
va=0x0000000000004000 pte=0x0000000000000000
panic: uvmunmap: not mapped
```

​	The "usertrap(): ..." message is from the user trap handler in trap.c; it has caught an exception that it does not know how to handle. Make sure you understand why this page fault occurs. The "stval=0x0..04008" indicates that the virtual address that caused the page fault is 0x4008.

​	发生错误的虚拟地址放在了 stval 寄存器 这个寄存器使用r_stval()函数读出，而中断原因放在了r_scause()寄存器。

```c
uint64 sys_sbrk(void)
{
  int addr;
  int n;

  if(argint(0, &n) < 0)
    return -1;
  addr = myproc()->sz;
  /*if(growproc(n) < 0)
    return -1;*/
  myproc()->sz=addr+n;
  return addr;
}
```

### Lazy allocation ([moderate](https://pdos.csail.mit.edu/6.828/2020/labs/guidance.html))

​	Modify the code in trap.c to respond to a page fault from user space by mapping a newly-allocated page of physical memory at the faulting address, and then returning back to user space to let the process continue executing. You should add your code just before the `printf` call that produced the "usertrap(): ..." message. Modify whatever other xv6 kernel code you need to in order to get `echo hi` to work.

​	修改trap.c中的代码，以处理来自用户空间的page fault，方法是将新分配的物理内存页面映射到故障地址，然后返回到用户空间，让进程继续执行。您应该在产生“usertrap()):...”消息的printf调用之前添加代码。修改您需要的任何其他xv6内核代码，以便让echo hi工作。

Here are some hints:

- You can check whether a fault is a page fault by seeing if r_scause() is 13 or 15 in usertrap().
- 你可以通过检查 r_scause()的状态是否是13或者15来判断是否是page fault的中断。
- `r_stval()` returns the RISC-V `stval` register, which contains the virtual address that caused the page fault.
- r_stval() 返回RISC-V `stval` 寄存器，这个寄存器包含错误发生的虚拟地址。
- Steal code from uvmalloc() in vm.c, which is what sbrk() calls (via growproc()). You'll need to call kalloc() and mappages().
- 参考vm.c的uvmalloc()的代码实现，sbrk通过growproc()来实现，你需要使用kalloc()和mappages()函数
- Use PGROUNDDOWN(va) to round the faulting virtual address down to a page boundary.
- 使用 PGROUNDDOWN(va) 来使错误的虚拟地址向下对齐页面。
- uvmunmap() will panic; modify it to not panic if some pages aren't mapped.unmap
- uvmunmap()将会报错，如果一些页面没有对齐，那么修改这个函数使其不报错。
- If the kernel crashes, look up sepc in kernel/kernel.asm
- 如果内核崩溃，通过使用sepc的值在kernel/kernel.asm中查找出错的汇编代码。
- Use your `vmprint` function from pgtbl lab to print the content of a page table.
- 使用在pgtbl实验中写的vmprint函数去打印页表。
- If you see the error "incomplete type proc", include "spinlock.h" then "proc.h".
- 如果看见 "incomplete type proc"这个错误，引用"spinlock.h"在"proc.h"之前。

If all goes well, your lazy allocation code should result in `echo hi` working. You should get at least one page fault (and thus lazy allocation), and perhaps two

如果一切顺利，你的懒加载的代码会显示如下，通过echo hi命令。你将得到至少一个page fault。

```c
else if (r_scause() == 13 || r_scause() == 15) // 13 是load page fault 15是 store page fault
  {
    uint64 error_virtual_addr = PGROUNDDOWN(r_stval());
    // alloc page use growproc idea
    // just alloc one page
    char *mem = kalloc(); // alloc one phyic page
    if (mem == 0)
    {
      uvmdealloc(p->pagetable, error_virtual_addr, error_virtual_addr + 1024);
      p->killed = 1;
    }
    else
    {
      memset(mem, 0, PGSIZE); // page set zero
      if (mappages(p->pagetable, error_virtual_addr, PGSIZE, (uint64)mem, PTE_W | PTE_R | PTE_U) != 0)
      {
        printf("alloc error!\n");
        kfree(mem);
        p->killed = 1;
      }
    }
  }
  
```

### Lazytests and Usertests ([moderate](https://pdos.csail.mit.edu/6.828/2020/labs/guidance.html))

​	We've supplied you with `lazytests`, an xv6 user program that tests some specific situations that may stress your lazy memory allocator. Modify your kernel code so that all of both `lazytests` and `usertests` pass.

​	我们支持你使用一个xv6的测试程序 `lazytests`，他会测试一些给你的代码带来压力下的特殊的情况，修改你的内核代码以便于通过这两个测试。

- Handle negative sbrk() arguments. 处理负数在sbrk()里面
- Kill a process if it page-faults on a virtual memory address higher than any allocated with sbrk().
- 如果page fault 发生的虚拟地址比任何通过sbrk分配的高。
- Handle the parent-to-child memory copy in fork() correctly.
- 当父进程通过sbrk 多申请了部分内存 但是没有分配 。当父进程使用fork去创建子进程的时候 那么未分配的部分也会随着跟过去。所以也会页面访问无效
- Handle the case in which a process passes a valid address from sbrk() to a system call such as read or write, but the memory for that address has not yet been allocated.
- 处理程序传递无效的地址从sbrk到syscall，比如read和write系统调用，但是这个虚拟内存指向的物理地址并没有被分配。使用read write系统调用的时候会把地址通过寄存器传递给内核，然后内核，会通过copyout和copyin函数读取物理内存 但是由于没有映射，所以会报错
- Handle out-of-memory correctly: if kalloc() fails in the page fault handler, kill the current process.
- Handle faults on the invalid page below the user stack.

Your solution is acceptable if your kernel passes lazytests and usertests:
