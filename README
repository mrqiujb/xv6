## Lab: Copy-on-Write Fork for xv6



Virtual memory provides a level of indirection: the kernel can intercept memory references by marking PTEs invalid or read-only, leading to page faults, and can change what addresses mean by modifying PTEs. There is a saying in computer systems that any systems problem can be solved with a level of indirection. The lazy allocation lab provided one example. This lab explores another example: copy-on write fork.

虚拟内存提供了一种间接层，内核能拦截内存的引用通过标记PTE无效或者只读。使用page faults修改PTE能改变地址的含义。计算机界有句谚语，任何系统的问题能够通过间接层用来解决。这个惰性分配实验提供了一个例子，本次lab探索了另外一个例子，cow。

### The problem

The fork() system call in xv6 copies all of the parent process's user-space memory into the child. If the parent is large, copying can take a long time. Worse, for example, a fork() followed by exec() in the child will cause the child to discard the copied memory, probably without ever using most of it. On the other hand, if both parent and child use a page, and one or both writes it, a copy is truly needed.

这个xv6中的fork系统调用会copy所有的父进程拥有的用户空间的内存给他的子进程。如果这个父进程非常大，复制内存这件事会占用大量的时间。更糟糕的是，举个例子，父进程在fork子进程后，子进程使用exec函数。这样会造成子进程丢弃拷贝的内存，通常这些内存大部分并没有使用。另一方面，如果父进程和子进程使用这个page，两者都想写page，这个时候确实需要分配真实的物理内存。

## The solution

The goal of copy-on-write (COW) fork() is to defer allocating and copying physical memory pages for the child until the copies are actually needed, if ever.

这个cow的目标是实现fork延迟为子进程分配和拷贝这个物理内存直到这个拷贝确实需要的时候。

COW fork() creates just a pagetable for the child, with PTEs for user memory pointing to the parent's physical pages. COW fork() marks all the user PTEs in both parent and child as not writable. When either process tries to write one of these COW pages, the CPU will force a page fault. The kernel page-fault handler detects this case, allocates a page of physical memory for the faulting process, copies the original page into the new page, and modifies the relevant PTE in the faulting process to refer to the new page, this time with the PTE marked writeable. When the page fault handler returns, the user process will be able to write its copy of the page.

cow的fork仅为他的子进程创建一个页表，这个用户内存的页表的PTE指向父进程的物理页。cow的fork将所有父进程和子进程的PTE标记为不可写。当其中一个进程尝试写的时候，这个cpu便会触发page fault。这个kernel的page fault 处理这个检测到的错误，分配物理页给触发fault的进程，并且拷贝父进程的page给子进程，并且在fault处理函数中更改相关的PTE使其指向新的页面，此时这个PTE被标记成可写的。当这个page fault处理返回的时候，这个用户进程将能够正常的完成写这些拷贝的页面。

COW fork() makes freeing of the physical pages that implement user memory a little trickier. A given physical page may be referred to by multiple processes' page tables, and should be freed only when the last reference disappears.

这个cow的fork使得释放物理页的实现变得非常麻烦，一个物理页被许多进程引用，只有当最后一个引用消失的时候才能释放。

## Implement copy-on write([hard](https://pdos.csail.mit.edu/6.828/2020/labs/guidance.html))



Your task is to implement copy-on-write fork in the xv6 kernel. You are done if your modified kernel executes both the cowtest and usertests programs successfully.

您的任务是在xv6内核中实现写时复制分叉。如果修改后的内核成功执行了cowtest和usertests程序，那么就完成了。

To help you test your implementation, we've provided an xv6 program called cowtest (source in user/cowtest.c). cowtest runs various tests, but even the first will fail on unmodified xv6. Thus, initially, you will see:
为了帮助您测试您的实现，我们提供了一个名为cowtest的xv6程序（source in user/cowtest.c）。cowtest运行各种测试，但即使是第一个测试也会在未经修改的xv6上失败。因此，最初，您将看到：

```shell
$ cowtest
simple: fork() failed
$ 
```

The "simple" test allocates more than half of available physical memory, and then fork()s. The fork fails because there is not enough free physical memory to give the child a complete copy of the parent's memory.

“Simple”测试分配了一半以上的可用物理内存，然后是fork()。叉子失败了，因为没有足够的自由物理记忆给孩子父母记忆的完整副本。

When you are done, your kernel should pass all the tests in both cowtest and usertests. That is:

完成后，您的内核应该通过cowtest和用户测试中的所有测试。那就是：

```shell
$ cowtest
simple: ok
simple: ok
three: zombie!
ok
three: zombie!
ok
three: zombie!
ok
file: ok
ALL COW TESTS PASSED
$ usertests
...
ALL TESTS PASSED
$
```

Here's a reasonable plan of attack.

这是个合理的实现的计划。

1. Modify uvmcopy() to map the parent's physical pages into the child, instead of allocating new pages. Clear `PTE_W` in the PTEs of both child and parent.
2. 修改uvmcopy函数去建立父进程的物理页和子进程之间的关系，而不是单纯的分配新的页，清除PTE_W和父进程和子进程都有的PTE
3. Modify usertrap() to recognize page faults. When a page-fault occurs on a COW page, allocate a new page with kalloc(), copy the old page to the new page, and install the new page in the PTE with `PTE_W` set.
4. 修改usertrap函数去识别page fault。当在cow发生page fault的时候，分配新的页使用kalloc，然后复制旧的页到新的页。并且重新设置PTE和PTE_W。
5. Ensure that each physical page is freed when the last PTE reference to it goes away -- but not before. A good way to do this is to keep, for each physical page, a "reference count" of the number of user page tables that refer to that page. Set a page's reference count to one when `kalloc()` allocates it. Increment a page's reference count when fork causes a child to share the page, and decrement a page's count each time any process drops the page from its page table. `kfree()` should only place a page back on the free list if its reference count is zero. It's OK to to keep these counts in a fixed-size array of integers. You'll have to work out a scheme for how to index the array and how to choose its size. For example, you could index the array with the page's physical address divided by 4096, and give the array a number of elements equal to highest physical address of any page placed on the free list by `kinit()` in kalloc.c.
6. 保证当最后一个PTE的引用消失之前不能释放这个物理页。一个做这件事的好的方式是为每个物理页保存一个引用计数，即引用该页的用户页表的数量。只有当kalloc分配页面的时候去设置这个计数。当fork导致子进程共享该页时，增加该页的引用计数;每当任何进程从其页表中删除该页时，减少该页的引用计数。如果引用计数为零，`kfree()`只应将页面放回自由列表中。在固定大小的整数数组中保留这些计数是可以的。例如，可以用页面的物理地址除以4096来索引数组，并为数组提供一些元素，这些元素等于kalloc中kinit()放置在空闲列表中的任何页面的最高物理地址。
7. Modify copyout() to use the same scheme as page faults when it encounters a COW page.
8. 修改copyout()以在遇到COW页时使用与页错误相同的方案

Some hints:

- The lazy page allocation lab has likely made you familiar with much of the xv6 kernel code that's relevant for copy-on-write. However, you should not base this lab on your lazy allocation solution; instead, please start with a fresh copy of xv6 as directed above.
- 惰性页分配实验室可能已经使您熟悉了许多与写时复制相关的xv6内核代码。然而，您不应该将本实验建立在懒惰分配解决方案的基础上;相反，请按照上面的指示从一个新的xv6副本开始。
- It may be useful to have a way to record, for each PTE, whether it is a COW mapping. You can use the RSW (reserved for software) bits in the RISC-V PTE for this.
- 有一种方法来记录每个PTE是否是COW映射可能是有用的。您可以在RISC-V PTE中使用RSW（为软件保留）位。
- `usertests` explores scenarios that `cowtest` does not test, so don't forget to check that all tests pass for both.
- “usertests”探索了cowtest无法测试的场景，因此不要忘记检查所有测试是否都通过了。
- Some helpful macros and definitions for page table flags are at the end of `kernel/riscv.h`.
- 一些有用的宏和页表标志的定义在kernel/riscv.h的末尾。
- If a COW page fault occurs and there's no free memory, the process should be killed.
- 如果出现COW页错误，并且没有空闲内存，则应该终止进程。

![img](https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MMidiGrWWP5Do6c9hwf%2F-MMk2SxJ_cq94IMH6I6W%2Fimage.png?alt=media&token=e0dad55b-5c74-4da0-a3b0-a89d462eda58)

​	如上，RSW为PTE的一个未使用的10位的两位，给用户使用，然后可以设置这个位来判断这个page fault是cow还是lazy allocation或者其他。

思路

1. 设置数组保存物理页的引用计数
2. 修改fork()使得 不直接分配物理页，修改pte标志位使两者都不可写，然后增加引用计数。
3. 修改uvmcopy 建立将原本应该分配子进程物理页的代码改成共享，共享的方式就是子进程的pte同样指向父进程指向的物理页
4. 修改usertrap，当子进程想要修改的时候重新分配页面给他，并且清除PTE_W
5. 修改kfree 当页面计数为0的时候才能真正的释放这块内存，否则不释放，而是计数减少



